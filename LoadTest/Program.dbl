import Synergex.SynergyDE.Select
import System.Collections.Generic
import System.Threading
.ifdef OS_VMS
.else
.define HAS_SEQ_KEYS 1
.endc

main
proc
    Console.WriteLine("press enter to initialize")
    Console.ReadLine()

    data threads = new List<Thread>()
    data i, int
    data thrd, @Thread

    for i from 1 thru 5 by 1
    begin
        threads.Add(new Thread(bob.billy.getThreadStart(i == 1)))
    end
    
    foreach thrd in threads
    begin
        thrd.IsBackground = false
        thrd.Start()
        Thread.Sleep(1000)
    end


    Console.WriteLine("started")
    Thread.Sleep(50000)

    foreach thrd in threads
        thrd.Join()

    Console.WriteLine("joined")
    Console.ReadLine()
endmain


;;; <summary>
;;; The main entry point for the application.
;;; </summary>
namespace bob
    class billy
        public static method getThreadStart, @ThreadStart
            isManager, boolean
        proc
            data result, @ThreadStart
            result = lambda() { main_load_test(isManager) }
            mreturn result
        endmethod

        public static method main_load_test, void
            isManager, boolean
            record
                getLogStatus, i4
                getLogBuffer, a28
                seedData, a6
                isControl, boolean
                isRace, boolean
                controlChannel, i4
                accountChannel, int
                transactionChannel, int
                seqControlChannel, int
                targetIterations, int, 10000
                targetClients, int, 4
        proc
            Thread.BeginThreadAffinity()
            try
            begin
                ;;getlog("MANAGER", getLogBuffer, getLogStatus)
                isRace = false
                if(!isRace) then
                begin
                    isControl = isManager;(getLogBuffer == "TRUE")
                    if(isControl) then
                    begin
                        Console.WriteLine("Manager: set by environment")
                    end
                    else
                    begin
                        Console.WriteLine("Not Manager: set by environment")
                    end
                end
                else
                begin
                    Console.WriteLine("Starting race to determine manager")
                end

                ;;getlog("SEED", getLogBuffer, getLogStatus)
                ;;if(getLogStatus) then
                ;;    seedData = getLogBuffer(1:6)
                ;;else
                ;;begin
                time(seedData)
                ;;end

                LoadTest.Rando.Seed1 = seedData(3:4)

                ;;if we're control we need to initialize files
                if(isRace || isControl) then
                begin
                    try
                    begin
                        data controlRecord, Control
                        init controlRecord
                        controlChannel = 0
.ifdef HAS_SEQ_KEYS
                        isamc("DAT:Control, COMPRESS, SGRFA", ^size(Control), 1, 
                        &    "start=1, length=8, type=sequence")
.else
            isamc("DAT:Control, COMPRESS", ^size(Control), 1, 
            &    "start=1, length=8, type=integer")
.endc

                        open(controlChannel = 0, U:I, "DAT:Control")
                        controlRecord.controlId = 1
                        store(controlChannel, controlRecord)
                        read(controlChannel, controlRecord, 1, WAIT:Q_NOWAIT, LOCK:Q_MANUAL_LOCK) [LOCK=notManager]
                    notManager,
                        if(controlRecord.controlId == 1) then
                        begin
                            isControl = true
                            Console.WriteLine("Manager")
                            xcall InitializeFiles(controlChannel, 10000)
                        end
                        else
                            isControl = false
                    end
                    catch(ex, @Exception)
                    begin
                        isControl = false
                        Console.WriteLine("Not Manager")
                        if(controlChannel != 0)
                            close(controlChannel)

                        open(controlChannel = 0, U:I, "DAT:Control")
                    end
                    endtry
                end
                else
                    open(controlChannel = 0, U:I, "DAT:Control")
    
                if(isControl) then
                begin
                    data totalBalance, d56.2
                    data totalTransactions, i8
                    data timeStart, d6
                    data timeEnd, d6
                    data totalSeconds, int
                    totalBalance = 0
                    open(accountChannel = 0, U:I, "DAT:Accounts")
                    Console.WriteLine("open account got {0} on thread {1}", accountChannel, Thread.CurrentThread.ManagedThreadId)
                    open(transactionChannel = 0, U:I, "DAT:Transactions")
                    Console.WriteLine("open transaction got {0} on thread {1}", transactionChannel, Thread.CurrentThread.ManagedThreadId)
                    ;;wait for user to press a key
                    ;;release the control record
                    Console.WriteLine("press enter to start")
                    Console.ReadLine()
                    xcall SignalStart(controlChannel, targetClients, targetIterations)
                    time(timeStart)
                    Console.WriteLine("starting")
                    xcall WaitForFinish(controlChannel, totalTransactions)
                    time(timeEnd)

                    totalSeconds = timeEnd(5:2) - timeStart(5:2)
                    totalSeconds += ((timeEnd(3:2) - timeStart(3:2)) * 60)
                    totalSeconds += ((timeEnd(1:2) - timeStart(1:2)) * 3600)

                    Console.WriteLine("Total Seconds: " + %string(totalSeconds))
                    xcall AccumulateTotalBalance(accountChannel, totalBalance)
                    Console.WriteLine("Total Balance: " + %string(totalBalance))
                    totalTransactions = targetIterations * targetClients
                    xcall ValidateAccountTransactions(totalTransactions)
                    Console.WriteLine("Validation Finished")
                end
                else
                begin
                    data i, int
                    data iterations, int, targetIterations
                    data maxAccountId, i8
                    xcall WaitForStart(controlChannel, iterations, maxAccountId)
                    open(accountChannel = 0, U:I, "DAT:Accounts")
                    Console.WriteLine("open account got {0} on thread {1}", accountChannel, Thread.CurrentThread.ManagedThreadId)
                    open(transactionChannel = 0, U:I, "DAT:Transactions")
                    Console.WriteLine("open transaction got {0} on thread {1}", transactionChannel, Thread.CurrentThread.ManagedThreadId)
.ifndef HAS_SEQ_KEYS
        open(seqControlChannel = 0, U:I, "DAT:SeqControl")
.endc

                    for i from 1 thru iterations by 1
                    begin
                        xcall RandomTransfer(accountChannel, transactionChannel, seqControlChannel, maxAccountId)
                    end

                    close accountChannel
                    close transactionChannel
.ifndef HAS_SEQ_KEYS
        close seqControlChannel
.endc
                    xcall SignalFinished(controlChannel)
                end
            end
            catch(ex, @Exception)
            begin
                Console.WriteLine(ex.ToString())
            end
            finally
            begin
                Console.WriteLine("ending")
            end

            endtry
            mreturn
        endmethod
    endclass
endnamespace


structure Control
    controlId, i8
    requestedProcessCount, int
    startedProcessCount, int
    finishedProcessCount, int
    desiredIterations, int
    maxAccountId, int
    nextSeed, int
endstructure

structure SeqControl
    controlId, i8
    nextTransactionId, i8
endstructure

structure Account
    accountId, i8
    lastUpdate, i8
    holderName, a128
    balance, d28.2
    noise, a4096
    lastTransactionId, i8
    crc, i4
endstructure

structure Transaction
    transactionId, i8
    transactionTime, i8
    sourceAccountId, i8
    destAccountId, i8
    amount, d28.2
endstructure

subroutine InitializeFiles
    controlChannel, i4
    accountCount, int
    record
        controlRecord, Control
        i, int
        accountChannel, int
        transactionChannel, int
        seqControlChannel, int
        seqControlRecord, SeqControl
proc
    init controlRecord
    init seqControlRecord
    seqControlRecord.controlId = 1
    xcall delet("DAT:Accounts")
    xcall delet("DAT:Transactions")
    ;;leave control channel locked
.ifdef HAS_SEQ_KEYS

    isamc("DAT:Accounts, COMPRESS, SGRFA, TBYTE", ^size(Account), 3, 
    &   "start=1, length=8, type=sequence", 
    &   "start=19, length=128, type=ALPHA, DUPS", "start=4260, length=8, type=INTEGER, DUPS, MODIFY")

    isamc("DAT:Transactions, COMPRESS, SGRFA", ^size(Transaction), 1, 
    &   "start=1, length=8, type=sequence")
.else
    xcall delet("DAT:SeqControl")
    isamc("DAT:Accounts, COMPRESS", ^size(Account), 3, 
    &   "start=1, length=8, type=INTEGER", 
    &   "start=19, length=128, type=ALPHA, DUPS", "start=4260, length=8, type=INTEGER, DUPS, MODIFY")

    isamc("DAT:Transactions, COMPRESS", ^size(Transaction), 1, 
    &   "start=1, length=8, type=INTEGER")
    isamc("DAT:SeqControl, COMPRESS", ^size(SeqControl), 1, 
    &   "start=1, length=8, type=INTEGER")

    open(seqControlChannel = 0, U:I, "DAT:SeqControl")
    
    store(seqControlChannel, seqControlRecord)
    
    close(seqControlChannel)
.endc

    open(accountChannel = 0, U:I, "DAT:Accounts", SHARE: Q_EXCL_RW)
    open(transactionChannel = 0, U:I, "DAT:Transactions")
    controlRecord.maxAccountId = accountCount
    for i from 1 thru accountCount by 1
    begin
        xcall InitializeAccount(accountChannel, 999, i)
    end

    close(accountChannel)
    close(transactionChannel)
    controlRecord.startedProcessCount = 0
    controlRecord.controlId = 1
    write(controlChannel, controlRecord)
    xreturn
endsubroutine

subroutine SignalStart
    controlChannel, i4
    targetProcessCount, int
    targetIterations, int
    record
        controlRecord, Control
proc
    init controlRecord
    read(controlChannel, controlRecord, 1)
    controlRecord.controlId = 1
    controlRecord.desiredIterations = targetIterations
    controlRecord.requestedProcessCount = targetProcessCount
    controlRecord.nextSeed = LoadTest.Rando.Random()
    write(controlChannel, controlRecord)
    xcall free(controlChannel)
    xreturn
endsubroutine

subroutine SignalFinished
    controlChannel, i4
    record
        controlRecord, Control
proc
    clear controlRecord
    read(controlChannel, controlRecord, 1, WAIT: Q_WAIT, LOCK: Q_AUTO_LOCK)
    incr controlRecord.finishedProcessCount
    write(controlChannel, controlRecord)
    xreturn
endsubroutine

subroutine InitializeAccount
    accountChannel, int
    in amount, d28.2
    in iterationVal, int
    record
        targetAccount, Account
        i, int
proc
    targetAccount.balance = amount
    for i from 1 thru ^size(targetAccount.noise) by 4
    begin
        targetAccount.noise(i:4) = LoadTest.Rando.Random()
    end
    targetAccount.holderName = "WILLY"+%string(LoadTest.Rando.Random()) + "BOB" + %string(LoadTest.Rando.Random()) + %string(LoadTest.Rando.Random())
.ifndef HAS_SEQ_KEYS
    targetAccount.accountId = iterationVal
.endc

    targetAccount.crc = BlockCRCForData(targetAccount(17:4252), 4252)
    
    store(accountChannel, targetAccount)
    xreturn
endsubroutine

subroutine AccumulateTotalBalance
    accountChannel, int
    out result, d.
    record
        accountRecord, Account
proc
    foreach accountRecord in new Select(new From(accountChannel, accountRecord))
    begin
        result += accountRecord.balance
        if(%BlockCRCForData(accountRecord(17:4252), 4252) != accountRecord.crc)
            Console.WriteLine("error in record")
    end
    xreturn
endsubroutine

subroutine ValidateAccountTransactions
    expectedCount, long
    record
        accountRecord, Account
        transactionRecord, Transaction
        lastTransactionId, i8
        transactionChan, int
proc
    ;;foreach transaction in transactions orderby transactionid
    ;;  ensure no duplicates and order is correct
    ;;  ensure no gaps

    ;;foreach account in accounts
    ;;  check last transactionid has matching transaction record
    lastTransactionId = 0
    foreach transactionRecord in new Select(new From("DAT:Transactions.ISM", transactionRecord), OrderBy.Ascending(transactionRecord.transactionId))
    begin
        if(transactionRecord.transactionId - lastTransactionId != 1)
            Console.WriteLine("invalid transaction sequence detected")

        if(transactionRecord.transactionId > expectedCount)
            Console.WriteLine("transactionid grew too high")

        lastTransactionId = transactionRecord.transactionId
    end

    open(transactionChan = 0, I:I, "DAT:Transactions")

    foreach accountRecord in new Select(new From("DAT:Accounts.ISM", accountRecord), OrderBy.Ascending(accountRecord.accountId))
    begin
        if(accountRecord.lastTransactionId != 0)
        begin
            read(transactionChan, transactionRecord, accountRecord.lastTransactionId, LOCK: Q_NO_LOCK)
            if(transactionRecord.sourceAccountId != accountRecord.accountId && transactionRecord.destAccountId != accountRecord.accountId)
            begin
                Console.WriteLine("transaction record was bound to the wrong account")
            end
        end
    end

    close(transactionChan)
    xreturn
endsubroutine


subroutine TransferFunds
    accountChan, int
    transactionChan, int
    seqControlChan, int
    sourceAccountId, i8
    destAccountId, i8
    amount, d28.2
    record work
        sourceAccount, Account
        destAccount, Account
        transactionRecord, Transaction
        seqControlRecord, SeqControl
        actualAmountTransfered, d28.2
        createdTransactionRFA, a10
proc
    clear work
    ;;load/lock both accounts
    read(accountChan, sourceAccount, sourceAccountId, KEYNUM:0, MATCH: Q_EQ, LOCK: Q_MANUAL_LOCK, WAIT: Q_WAIT)
    read(accountChan, destAccount, destAccountId, KEYNUM:0, MATCH: Q_EQ, LOCK: Q_MANUAL_LOCK, WAIT: Q_WAIT)

    ;;ensure sufficiant funds
    if(sourceAccount.balance > amount) then
    begin
        actualAmountTransfered = amount
    end
    else
    begin
        actualAmountTransfered = sourceAccount.balance
    end
    
    sourceAccount.balance -= actualAmountTransfered
    destAccount.balance += actualAmountTransfered
    
    ;;add transaction record
.ifndef HAS_SEQ_KEYS
    read(seqControlChan, seqControlRecord, 1, WAIT: Q_WAIT)
    incr seqControlRecord.nextTransactionId
    write(seqControlChan, seqControlRecord)
    transactionRecord.transactionId = seqControlRecord.nextTransactionId
.endc
    transactionRecord.destAccountId = destAccount.accountId
    transactionRecord.sourceAccountId = sourceAccount.accountId
    transactionRecord.amount = actualAmountTransfered

    store(transactionChan, transactionRecord, GETRFA: createdTransactionRFA)
    read(transactionChan, transactionRecord, RFA: createdTransactionRFA, WAIT: Q_WAIT, LOCK: Q_NO_LOCK)
    ;;update last transactionid in both accounts
    sourceAccount.lastTransactionId = transactionRecord.transactionId
    destAccount.lastTransactionId = transactionRecord.transactionId
    ;;update crc both accounts
    sourceAccount.crc = BlockCRCForData(sourceAccount(17:4252), 4252) 
    destAccount.crc = BlockCRCForData(destAccount(17:4252), 4252)

    ;;write/unlock both accounts
    ;;dest was last positioned so we are already on it
    write(accountChan, destAccount)
    ;;sourceAccount needs to be positioned to but its already locked with Q_MANUAL_LOCK
    find(accountChan,, sourceAccountId)
    write(accountChan, sourceAccount)
    xcall free(accountChan)
    xcall free(transactionChan)
    xreturn
endsubroutine

subroutine RandomTransfer
    accountChan, int
    transactionChan, int
    seqControlChan, int
    maxAccountId, long
    record
        target1, i8
        target2, i8
proc
    do forever
    begin
        target1 = Modulo(LoadTest.Rando.Random(), maxAccountId) + 1
        target2 = Modulo(LoadTest.Rando.Random(), maxAccountId) + 1
        if(target1 != target2)
            exitloop
    end
    
    xcall TransferFunds(accountChan, transactionChan, seqControlChan, target1, target2, 100)
    xreturn
endsubroutine

subroutine WaitForStart
    controlChannel, i4
    out iterations, int
    out maxAccountId, i8
    record
        controlRecord, Control
proc
    clear controlRecord
    read(controlChannel, controlRecord, 1, WAIT: Q_WAIT, LOCK: Q_AUTO_LOCK)
    ;;if(controlRecord.startedProcessCount >= controlRecord.requestedProcessCount)
    ;;    throw new Exception("too many processes")

    incr controlRecord.startedProcessCount
    iterations = controlRecord.desiredIterations
    maxAccountId = controlRecord.maxAccountId
    LoadTest.Rando.Seed1 = controlRecord.nextSeed
    controlRecord.nextSeed = LoadTest.Rando.Random()
    write(controlChannel, controlRecord)
    xreturn
endsubroutine

subroutine WaitForFinish
    controlChannel, i4
    out totalTransactions, i8
    record
        controlRecord, Control
proc
    ;;do forever
    ;;read control
    ;;  check for startedProcessCount to equal requestedProcessCount and finishedProcessCount
    ;;      xreturn
    ;;  else unlock
    free(controlChannel)
    do forever
    begin
        read(controlChannel, controlRecord, 1, LOCK:Q_AUTO_LOCK, WAIT: Q_WAIT)
        if(controlRecord.startedProcessCount == controlRecord.requestedProcessCount && 
        &    controlRecord.requestedProcessCount == controlRecord.finishedProcessCount) then
        begin
            xreturn
        end
        else
        begin
            free(controlChannel)
            Thread.Sleep(1000)
        end
    end
endsubroutine

function Modulo, int
    in arg1, int
    in arg2, long
proc
    freturn arg1 - arg2 * (arg1 / arg2)
endfunction


;;alphaData length must be divisible by 4
function BlockCRCForData, int
    alphaData, a
    length, i
    record
        i, int
        result, int
        intData, int
proc
    if(%Modulo(length, 4) != 0)
        throw new Exception("length was not divisible by 4")

    result = 0
    for i from 1 thru length by 4
    begin
        intData = ^i(alphaData(i:4))
        result = result .bxor. intData 
    end
    freturn result
endfunction

namespace LoadTest
    class Rando
        public static Seed1, int
        public static Seed2, int
        public static method Random, int
            record
                result, int
        proc
            xcall randm(result, Seed1, Seed2)
            mreturn result
        endmethod
    endclass

endnamespace







;;;*****************************************************************************
;;;
;;; Title:       SelfHost.dbl
;;;
;;; Description: A program to self-host Harmony Core services
;;;
;;;*****************************************************************************
;;; WARNING: GENERATED CODE!
;;; This file was generated by CodeGen. Avoid editing the file if possible.
;;; Any changes you make will be lost of the file is re-generated.
;;;*****************************************************************************
;
;import Microsoft.AspNetCore
;import Microsoft.AspNetCore.Hosting
;import System.Collections.Generic
;import System.IO
;import System.Text
;import LoadTest
;import LoadTest.Models
;main SelfHost
;
;proc
;	;;Configure the environment
;	try
;	begin
;		data accountRec, strAccount
;		data accountChn, i4
;		data i, i4
;		data fileName = "accounts.ism"
;		if(File.Exists(fileName))
;            System.IO.File.Delete(fileName)
;		xcall isamc(fileName, 16, 1, "start=1, len=6, type=DECIMAL, name=name")	
;		open(accountChn, U:I, fileName)
;		for i from 1 thru 10000 by 1
;		begin
;			accountRec.accountNumber = i
;			accountRec.balance = 1000
;			store(accountChn, accountRec)
;		end
;		close accountChn
;	end
;	catch (ex, @Exception)
;	begin
;		Console.WriteLine(ex.Message)
;		Console.Write("Press a key to terminate: ")
;		Console.ReadKey()
;		stop
;	end
;	endtry
;
;
;
;
;;	Console.WriteLine("API documentation is available at https://localhost:8086/api-docs")
;;
;;	data wwwroot = Path.Combine(AppContext.BaseDirectory, "wwwroot")
;;
;;	;;Make sure the wwwroot folder is present
;;	if (!Directory.Exists(wwwroot))
;;		Directory.CreateDirectory(wwwroot)
;;
;;	;;Start self-hosting (Kestrel)
;;	WebHost.CreateDefaultBuilder(new string[0])
;;	&	.UseContentRoot(wwwroot)
;;	&	.UseWebRoot(wwwroot)
;;	&	.UseStartup<Startup>()
;;	&	.UseUrls("http://localhost:8085", "https://localhost:8086")
;;	&	.Build()
;;	&	.Run()
;
;
;endmain
;